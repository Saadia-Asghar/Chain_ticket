(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,6685,e=>{"use strict";var t=e.i(8861),r=e.i(96516);function a(e,a){if(!(0,r.isAddress)(e,{strict:!1}))throw new t.InvalidAddressError({address:e});if(!(0,r.isAddress)(a,{strict:!1}))throw new t.InvalidAddressError({address:a});return e.toLowerCase()===a.toLowerCase()}e.s(["isAddressEqual",()=>a])},9963,e=>{"use strict";var t=e.i(89509),r=e.i(34888),a=e.i(69934),s=e.i(63710);class o extends a.BaseError{constructor({callbackSelector:e,cause:t,data:r,extraData:a,sender:o,urls:n}){super(t.shortMessage||"An error occurred while fetching for an offchain result.",{cause:t,metaMessages:[...t.metaMessages||[],t.metaMessages?.length?"":[],"Offchain Gateway Call:",n&&["  Gateway URL(s):",...n.map(e=>`    ${(0,s.getUrl)(e)}`)],`  Sender: ${o}`,`  Data: ${r}`,`  Callback selector: ${e}`,`  Extra data: ${a}`].flat(),name:"OffchainLookupError"})}}class n extends a.BaseError{constructor({result:e,url:t}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${(0,s.getUrl)(t)}`,`Response: ${(0,r.stringify)(e)}`],name:"OffchainLookupResponseMalformedError"})}}class i extends a.BaseError{constructor({sender:e,to:t}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${t}`,`OffchainLookup sender address: ${e}`],name:"OffchainLookupSenderMismatchError"})}}var c=e.i(95767),u=e.i(59953),d=e.i(4434),l=e.i(6685),f=e.i(47526),p=e.i(80841),h=e.i(52012),w=e.i(27343),m=e.i(70204),y=e.i(90063),b=e.i(79617),g=e.i(49311),A=e.i(32881),E=e.i(27173);let F="/docs/contract/encodeErrorResult";function R(e){let{abi:t,errorName:r,args:a}=e,s=t[0];if(r){let e=(0,E.getAbiItem)({abi:t,args:a,name:r});if(!e)throw new m.AbiErrorNotFoundError(r,{docsPath:F});s=e}if("error"!==s.type)throw new m.AbiErrorNotFoundError(void 0,{docsPath:F});let o=(0,A.formatAbiItem)(s),n=(0,b.toFunctionSelector)(o),i="0x";if(a&&a.length>0){if(!s.inputs)throw new m.AbiErrorInputsNotFoundError(s.name,{docsPath:F});i=(0,d.encodeAbiParameters)(s.inputs,a)}return(0,f.concatHex)([n,i])}let v="/docs/contract/encodeFunctionResult",O="x-batch-gateway:true";async function P(e){let{data:t,ccipRequest:r}=e,{args:[a]}=function(e){let{abi:t,data:r}=e,a=(0,y.slice)(r,0,4),s=t.find(e=>"function"===e.type&&a===(0,b.toFunctionSelector)((0,A.formatAbiItem)(e)));if(!s)throw new m.AbiFunctionSignatureNotFoundError(a,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:s.name,args:"inputs"in s&&s.inputs&&s.inputs.length>0?(0,g.decodeAbiParameters)(s.inputs,(0,y.slice)(r,4)):void 0}}({abi:h.batchGatewayAbi,data:t}),s=[],o=[];return await Promise.all(a.map(async(e,t)=>{try{o[t]=e.urls.includes(O)?await P({data:e.data,ccipRequest:r}):await r(e),s[t]=!1}catch(e){var a;s[t]=!0,o[t]="HttpRequestError"===(a=e).name&&a.status?R({abi:h.batchGatewayAbi,errorName:"HttpError",args:[a.status,a.shortMessage]}):R({abi:[w.solidityError],errorName:"Error",args:["shortMessage"in a?a.shortMessage:a.message]})}})),function(e){let{abi:t,functionName:r,result:a}=e,s=t[0];if(r){let e=(0,E.getAbiItem)({abi:t,name:r});if(!e)throw new m.AbiFunctionNotFoundError(r,{docsPath:v});s=e}if("function"!==s.type)throw new m.AbiFunctionNotFoundError(void 0,{docsPath:v});if(!s.outputs)throw new m.AbiFunctionOutputsNotFoundError(s.name,{docsPath:v});let o=(()=>{if(0===s.outputs.length)return[];if(1===s.outputs.length)return[a];if(Array.isArray(a))return a;throw new m.InvalidArrayError(a)})();return(0,d.encodeAbiParameters)(s.outputs,o)}({abi:h.batchGatewayAbi,functionName:"query",result:[s,o]})}let x={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function L(e,{blockNumber:r,blockTag:a,data:s,to:n}){let{args:c}=(0,u.decodeErrorResult)({data:s,abi:[x]}),[p,h,w,m,y]=c,{ccipRead:b}=e,g=b&&"function"==typeof b?.request?b.request:k;try{if(!(0,l.isAddressEqual)(n,p))throw new i({sender:p,to:n});let s=h.includes(O)?await P({data:w,ccipRequest:g}):await g({data:w,sender:p,urls:h}),{data:o}=await (0,t.call)(e,{blockNumber:r,blockTag:a,data:(0,f.concat)([m,(0,d.encodeAbiParameters)([{type:"bytes"},{type:"bytes"}],[s,y])]),to:n});return o}catch(e){throw new o({callbackSelector:m,cause:e,data:s,extraData:y,sender:p,urls:h})}}async function k({data:e,sender:t,urls:a}){let s=Error("An unknown error occurred.");for(let o=0;o<a.length;o++){let i=a[o],u=i.includes("{data}")?"GET":"POST",d="POST"===u?{data:e,sender:t}:void 0,l="POST"===u?{"Content-Type":"application/json"}:{};try{let a,o=await fetch(i.replace("{sender}",t.toLowerCase()).replace("{data}",e),{body:JSON.stringify(d),headers:l,method:u});if(a=o.headers.get("Content-Type")?.startsWith("application/json")?(await o.json()).data:await o.text(),!o.ok){s=new c.HttpRequestError({body:d,details:a?.error?(0,r.stringify)(a.error):o.statusText,headers:o.headers,status:o.status,url:i});continue}if(!(0,p.isHex)(a)){s=new n({result:a,url:i});continue}return a}catch(e){s=new c.HttpRequestError({body:d,details:e.message,url:i})}}throw s}e.s(["ccipRequest",()=>k,"offchainLookup",()=>L,"offchainLookupAbiItem",0,x,"offchainLookupSignature",0,"0x556f1830"],9963)}]);